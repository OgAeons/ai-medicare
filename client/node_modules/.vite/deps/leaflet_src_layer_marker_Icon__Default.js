import "./chunk-G3PMV62Z.js";

// node_modules/leaflet/src/core/Util.js
function extend(dest) {
  var i, j, len, src;
  for (j = 1, len = arguments.length; j < len; j++) {
    src = arguments[j];
    for (i in src) {
      dest[i] = src[i];
    }
  }
  return dest;
}
var create = Object.create || /* @__PURE__ */ function() {
  function F() {
  }
  return function(proto) {
    F.prototype = proto;
    return new F();
  };
}();
var lastId = 0;
function stamp(obj) {
  if (!("_leaflet_id" in obj)) {
    obj["_leaflet_id"] = ++lastId;
  }
  return obj._leaflet_id;
}
function falseFn() {
  return false;
}
function formatNum(num, precision) {
  if (precision === false) {
    return num;
  }
  var pow = Math.pow(10, precision === void 0 ? 6 : precision);
  return Math.round(num * pow) / pow;
}
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
}
function splitWords(str) {
  return trim(str).split(/\s+/);
}
function setOptions(obj, options) {
  if (!Object.prototype.hasOwnProperty.call(obj, "options")) {
    obj.options = obj.options ? create(obj.options) : {};
  }
  for (var i in options) {
    obj.options[i] = options[i];
  }
  return obj.options;
}
var isArray = Array.isArray || function(obj) {
  return Object.prototype.toString.call(obj) === "[object Array]";
};
function indexOf(array, el) {
  for (var i = 0; i < array.length; i++) {
    if (array[i] === el) {
      return i;
    }
  }
  return -1;
}
function getPrefixed(name) {
  return window["webkit" + name] || window["moz" + name] || window["ms" + name];
}
var lastTime = 0;
function timeoutDefer(fn) {
  var time = +/* @__PURE__ */ new Date(), timeToCall = Math.max(0, 16 - (time - lastTime));
  lastTime = time + timeToCall;
  return window.setTimeout(fn, timeToCall);
}
var requestFn = window.requestAnimationFrame || getPrefixed("RequestAnimationFrame") || timeoutDefer;
var cancelFn = window.cancelAnimationFrame || getPrefixed("CancelAnimationFrame") || getPrefixed("CancelRequestAnimationFrame") || function(id) {
  window.clearTimeout(id);
};

// node_modules/leaflet/src/core/Class.js
function Class() {
}
Class.extend = function(props) {
  var NewClass = function() {
    setOptions(this);
    if (this.initialize) {
      this.initialize.apply(this, arguments);
    }
    this.callInitHooks();
  };
  var parentProto = NewClass.__super__ = this.prototype;
  var proto = create(parentProto);
  proto.constructor = NewClass;
  NewClass.prototype = proto;
  for (var i in this) {
    if (Object.prototype.hasOwnProperty.call(this, i) && i !== "prototype" && i !== "__super__") {
      NewClass[i] = this[i];
    }
  }
  if (props.statics) {
    extend(NewClass, props.statics);
  }
  if (props.includes) {
    checkDeprecatedMixinEvents(props.includes);
    extend.apply(null, [proto].concat(props.includes));
  }
  extend(proto, props);
  delete proto.statics;
  delete proto.includes;
  if (proto.options) {
    proto.options = parentProto.options ? create(parentProto.options) : {};
    extend(proto.options, props.options);
  }
  proto._initHooks = [];
  proto.callInitHooks = function() {
    if (this._initHooksCalled) {
      return;
    }
    if (parentProto.callInitHooks) {
      parentProto.callInitHooks.call(this);
    }
    this._initHooksCalled = true;
    for (var i2 = 0, len = proto._initHooks.length; i2 < len; i2++) {
      proto._initHooks[i2].call(this);
    }
  };
  return NewClass;
};
Class.include = function(props) {
  var parentOptions = this.prototype.options;
  extend(this.prototype, props);
  if (props.options) {
    this.prototype.options = parentOptions;
    this.mergeOptions(props.options);
  }
  return this;
};
Class.mergeOptions = function(options) {
  extend(this.prototype.options, options);
  return this;
};
Class.addInitHook = function(fn) {
  var args = Array.prototype.slice.call(arguments, 1);
  var init = typeof fn === "function" ? fn : function() {
    this[fn].apply(this, args);
  };
  this.prototype._initHooks = this.prototype._initHooks || [];
  this.prototype._initHooks.push(init);
  return this;
};
function checkDeprecatedMixinEvents(includes) {
  if (typeof L === "undefined" || !L || !L.Mixin) {
    return;
  }
  includes = isArray(includes) ? includes : [includes];
  for (var i = 0; i < includes.length; i++) {
    if (includes[i] === L.Mixin.Events) {
      console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", new Error().stack);
    }
  }
}

// node_modules/leaflet/src/geometry/Point.js
function Point(x, y, round) {
  this.x = round ? Math.round(x) : x;
  this.y = round ? Math.round(y) : y;
}
var trunc = Math.trunc || function(v) {
  return v > 0 ? Math.floor(v) : Math.ceil(v);
};
Point.prototype = {
  // @method clone(): Point
  // Returns a copy of the current point.
  clone: function() {
    return new Point(this.x, this.y);
  },
  // @method add(otherPoint: Point): Point
  // Returns the result of addition of the current and the given points.
  add: function(point) {
    return this.clone()._add(toPoint(point));
  },
  _add: function(point) {
    this.x += point.x;
    this.y += point.y;
    return this;
  },
  // @method subtract(otherPoint: Point): Point
  // Returns the result of subtraction of the given point from the current.
  subtract: function(point) {
    return this.clone()._subtract(toPoint(point));
  },
  _subtract: function(point) {
    this.x -= point.x;
    this.y -= point.y;
    return this;
  },
  // @method divideBy(num: Number): Point
  // Returns the result of division of the current point by the given number.
  divideBy: function(num) {
    return this.clone()._divideBy(num);
  },
  _divideBy: function(num) {
    this.x /= num;
    this.y /= num;
    return this;
  },
  // @method multiplyBy(num: Number): Point
  // Returns the result of multiplication of the current point by the given number.
  multiplyBy: function(num) {
    return this.clone()._multiplyBy(num);
  },
  _multiplyBy: function(num) {
    this.x *= num;
    this.y *= num;
    return this;
  },
  // @method scaleBy(scale: Point): Point
  // Multiply each coordinate of the current point by each coordinate of
  // `scale`. In linear algebra terms, multiply the point by the
  // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
  // defined by `scale`.
  scaleBy: function(point) {
    return new Point(this.x * point.x, this.y * point.y);
  },
  // @method unscaleBy(scale: Point): Point
  // Inverse of `scaleBy`. Divide each coordinate of the current point by
  // each coordinate of `scale`.
  unscaleBy: function(point) {
    return new Point(this.x / point.x, this.y / point.y);
  },
  // @method round(): Point
  // Returns a copy of the current point with rounded coordinates.
  round: function() {
    return this.clone()._round();
  },
  _round: function() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  },
  // @method floor(): Point
  // Returns a copy of the current point with floored coordinates (rounded down).
  floor: function() {
    return this.clone()._floor();
  },
  _floor: function() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  },
  // @method ceil(): Point
  // Returns a copy of the current point with ceiled coordinates (rounded up).
  ceil: function() {
    return this.clone()._ceil();
  },
  _ceil: function() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  },
  // @method trunc(): Point
  // Returns a copy of the current point with truncated coordinates (rounded towards zero).
  trunc: function() {
    return this.clone()._trunc();
  },
  _trunc: function() {
    this.x = trunc(this.x);
    this.y = trunc(this.y);
    return this;
  },
  // @method distanceTo(otherPoint: Point): Number
  // Returns the cartesian distance between the current and the given points.
  distanceTo: function(point) {
    point = toPoint(point);
    var x = point.x - this.x, y = point.y - this.y;
    return Math.sqrt(x * x + y * y);
  },
  // @method equals(otherPoint: Point): Boolean
  // Returns `true` if the given point has the same coordinates.
  equals: function(point) {
    point = toPoint(point);
    return point.x === this.x && point.y === this.y;
  },
  // @method contains(otherPoint: Point): Boolean
  // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
  contains: function(point) {
    point = toPoint(point);
    return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);
  },
  // @method toString(): String
  // Returns a string representation of the point for debugging purposes.
  toString: function() {
    return "Point(" + formatNum(this.x) + ", " + formatNum(this.y) + ")";
  }
};
function toPoint(x, y, round) {
  if (x instanceof Point) {
    return x;
  }
  if (isArray(x)) {
    return new Point(x[0], x[1]);
  }
  if (x === void 0 || x === null) {
    return x;
  }
  if (typeof x === "object" && "x" in x && "y" in x) {
    return new Point(x.x, x.y);
  }
  return new Point(x, y, round);
}

// node_modules/leaflet/src/layer/vector/SVG.Util.js
function svgCreate(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}

// node_modules/leaflet/src/core/Browser.js
var style = document.documentElement.style;
var ie = "ActiveXObject" in window;
var ielt9 = ie && !document.addEventListener;
var edge = "msLaunchUri" in navigator && !("documentMode" in document);
var webkit = userAgentContains("webkit");
var android = userAgentContains("android");
var android23 = userAgentContains("android 2") || userAgentContains("android 3");
var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10);
var androidStock = android && userAgentContains("Google") && webkitVer < 537 && !("AudioNode" in window);
var opera = !!window.opera;
var chrome = !edge && userAgentContains("chrome");
var gecko = userAgentContains("gecko") && !webkit && !opera && !ie;
var safari = !chrome && userAgentContains("safari");
var phantom = userAgentContains("phantom");
var opera12 = "OTransition" in style;
var win = navigator.platform.indexOf("Win") === 0;
var ie3d = ie && "transition" in style;
var webkit3d = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix() && !android23;
var gecko3d = "MozPerspective" in style;
var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;
var mobile = typeof orientation !== "undefined" || userAgentContains("mobile");
var mobileWebkit = mobile && webkit;
var mobileWebkit3d = mobile && webkit3d;
var msPointer = !window.PointerEvent && window.MSPointerEvent;
var pointer = !!(window.PointerEvent || msPointer);
var touchNative = "ontouchstart" in window || !!window.TouchEvent;
var touch = !window.L_NO_TOUCH && (touchNative || pointer);
var mobileOpera = mobile && opera;
var mobileGecko = mobile && gecko;
var retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1;
var passiveEvents = function() {
  var supportsPassiveOption = false;
  try {
    var opts = Object.defineProperty({}, "passive", {
      get: function() {
        supportsPassiveOption = true;
      }
    });
    window.addEventListener("testPassiveEventSupport", falseFn, opts);
    window.removeEventListener("testPassiveEventSupport", falseFn, opts);
  } catch (e) {
  }
  return supportsPassiveOption;
}();
var canvas = function() {
  return !!document.createElement("canvas").getContext;
}();
var svg = !!(document.createElementNS && svgCreate("svg").createSVGRect);
var inlineSvg = !!svg && function() {
  var div = document.createElement("div");
  div.innerHTML = "<svg/>";
  return (div.firstChild && div.firstChild.namespaceURI) === "http://www.w3.org/2000/svg";
}();
var vml = !svg && function() {
  try {
    var div = document.createElement("div");
    div.innerHTML = '<v:shape adj="1"/>';
    var shape = div.firstChild;
    shape.style.behavior = "url(#default#VML)";
    return shape && typeof shape.adj === "object";
  } catch (e) {
    return false;
  }
}();
var mac = navigator.platform.indexOf("Mac") === 0;
var linux = navigator.platform.indexOf("Linux") === 0;
function userAgentContains(str) {
  return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
}
var Browser_default = {
  ie,
  ielt9,
  edge,
  webkit,
  android,
  android23,
  androidStock,
  opera,
  chrome,
  gecko,
  safari,
  phantom,
  opera12,
  win,
  ie3d,
  webkit3d,
  gecko3d,
  any3d,
  mobile,
  mobileWebkit,
  mobileWebkit3d,
  msPointer,
  pointer,
  touch,
  touchNative,
  mobileOpera,
  mobileGecko,
  retina,
  passiveEvents,
  canvas,
  svg,
  vml,
  inlineSvg,
  mac,
  linux
};

// node_modules/leaflet/src/layer/marker/Icon.js
var Icon = Class.extend({
  /* @section
   * @aka Icon options
   *
   * @option iconUrl: String = null
   * **(required)** The URL to the icon image (absolute or relative to your script path).
   *
   * @option iconRetinaUrl: String = null
   * The URL to a retina sized version of the icon image (absolute or relative to your
   * script path). Used for Retina screen devices.
   *
   * @option iconSize: Point = null
   * Size of the icon image in pixels.
   *
   * @option iconAnchor: Point = null
   * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
   * will be aligned so that this point is at the marker's geographical location. Centered
   * by default if size is specified, also can be set in CSS with negative margins.
   *
   * @option popupAnchor: Point = [0, 0]
   * The coordinates of the point from which popups will "open", relative to the icon anchor.
   *
   * @option tooltipAnchor: Point = [0, 0]
   * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
   *
   * @option shadowUrl: String = null
   * The URL to the icon shadow image. If not specified, no shadow image will be created.
   *
   * @option shadowRetinaUrl: String = null
   *
   * @option shadowSize: Point = null
   * Size of the shadow image in pixels.
   *
   * @option shadowAnchor: Point = null
   * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
   * as iconAnchor if not specified).
   *
   * @option className: String = ''
   * A custom class name to assign to both icon and shadow images. Empty by default.
   */
  options: {
    popupAnchor: [0, 0],
    tooltipAnchor: [0, 0],
    // @option crossOrigin: Boolean|String = false
    // Whether the crossOrigin attribute will be added to the tiles.
    // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
    // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
    crossOrigin: false
  },
  initialize: function(options) {
    setOptions(this, options);
  },
  // @method createIcon(oldIcon?: HTMLElement): HTMLElement
  // Called internally when the icon has to be shown, returns a `<img>` HTML element
  // styled according to the options.
  createIcon: function(oldIcon) {
    return this._createIcon("icon", oldIcon);
  },
  // @method createShadow(oldIcon?: HTMLElement): HTMLElement
  // As `createIcon`, but for the shadow beneath it.
  createShadow: function(oldIcon) {
    return this._createIcon("shadow", oldIcon);
  },
  _createIcon: function(name, oldIcon) {
    var src = this._getIconUrl(name);
    if (!src) {
      if (name === "icon") {
        throw new Error("iconUrl not set in Icon options (see the docs).");
      }
      return null;
    }
    var img = this._createImg(src, oldIcon && oldIcon.tagName === "IMG" ? oldIcon : null);
    this._setIconStyles(img, name);
    if (this.options.crossOrigin || this.options.crossOrigin === "") {
      img.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
    }
    return img;
  },
  _setIconStyles: function(img, name) {
    var options = this.options;
    var sizeOption = options[name + "Size"];
    if (typeof sizeOption === "number") {
      sizeOption = [sizeOption, sizeOption];
    }
    var size = toPoint(sizeOption), anchor = toPoint(name === "shadow" && options.shadowAnchor || options.iconAnchor || size && size.divideBy(2, true));
    img.className = "leaflet-marker-" + name + " " + (options.className || "");
    if (anchor) {
      img.style.marginLeft = -anchor.x + "px";
      img.style.marginTop = -anchor.y + "px";
    }
    if (size) {
      img.style.width = size.x + "px";
      img.style.height = size.y + "px";
    }
  },
  _createImg: function(src, el) {
    el = el || document.createElement("img");
    el.src = src;
    return el;
  },
  _getIconUrl: function(name) {
    return Browser_default.retina && this.options[name + "RetinaUrl"] || this.options[name + "Url"];
  }
});

// node_modules/leaflet/src/dom/DomEvent.Pointer.js
var POINTER_DOWN = Browser_default.msPointer ? "MSPointerDown" : "pointerdown";
var POINTER_MOVE = Browser_default.msPointer ? "MSPointerMove" : "pointermove";
var POINTER_UP = Browser_default.msPointer ? "MSPointerUp" : "pointerup";
var POINTER_CANCEL = Browser_default.msPointer ? "MSPointerCancel" : "pointercancel";
var pEvent = {
  touchstart: POINTER_DOWN,
  touchmove: POINTER_MOVE,
  touchend: POINTER_UP,
  touchcancel: POINTER_CANCEL
};
var handle = {
  touchstart: _onPointerStart,
  touchmove: _handlePointer,
  touchend: _handlePointer,
  touchcancel: _handlePointer
};
var _pointers = {};
var _pointerDocListener = false;
function addPointerListener(obj, type, handler) {
  if (type === "touchstart") {
    _addPointerDocListener();
  }
  if (!handle[type]) {
    console.warn("wrong event specified:", type);
    return falseFn;
  }
  handler = handle[type].bind(this, handler);
  obj.addEventListener(pEvent[type], handler, false);
  return handler;
}
function removePointerListener(obj, type, handler) {
  if (!pEvent[type]) {
    console.warn("wrong event specified:", type);
    return;
  }
  obj.removeEventListener(pEvent[type], handler, false);
}
function _globalPointerDown(e) {
  _pointers[e.pointerId] = e;
}
function _globalPointerMove(e) {
  if (_pointers[e.pointerId]) {
    _pointers[e.pointerId] = e;
  }
}
function _globalPointerUp(e) {
  delete _pointers[e.pointerId];
}
function _addPointerDocListener() {
  if (!_pointerDocListener) {
    document.addEventListener(POINTER_DOWN, _globalPointerDown, true);
    document.addEventListener(POINTER_MOVE, _globalPointerMove, true);
    document.addEventListener(POINTER_UP, _globalPointerUp, true);
    document.addEventListener(POINTER_CANCEL, _globalPointerUp, true);
    _pointerDocListener = true;
  }
}
function _handlePointer(handler, e) {
  if (e.pointerType === (e.MSPOINTER_TYPE_MOUSE || "mouse")) {
    return;
  }
  e.touches = [];
  for (var i in _pointers) {
    e.touches.push(_pointers[i]);
  }
  e.changedTouches = [e];
  handler(e);
}
function _onPointerStart(handler, e) {
  if (e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH) {
    preventDefault(e);
  }
  _handlePointer(handler, e);
}

// node_modules/leaflet/src/dom/DomEvent.DoubleTap.js
function makeDblclick(event) {
  var newEvent = {}, prop, i;
  for (i in event) {
    prop = event[i];
    newEvent[i] = prop && prop.bind ? prop.bind(event) : prop;
  }
  event = newEvent;
  newEvent.type = "dblclick";
  newEvent.detail = 2;
  newEvent.isTrusted = false;
  newEvent._simulated = true;
  return newEvent;
}
var delay = 200;
function addDoubleTapListener(obj, handler) {
  obj.addEventListener("dblclick", handler);
  var last = 0, detail;
  function simDblclick(e) {
    if (e.detail !== 1) {
      detail = e.detail;
      return;
    }
    if (e.pointerType === "mouse" || e.sourceCapabilities && !e.sourceCapabilities.firesTouchEvents) {
      return;
    }
    var path = getPropagationPath(e);
    if (path.some(function(el) {
      return el instanceof HTMLLabelElement && el.attributes.for;
    }) && !path.some(function(el) {
      return el instanceof HTMLInputElement || el instanceof HTMLSelectElement;
    })) {
      return;
    }
    var now = Date.now();
    if (now - last <= delay) {
      detail++;
      if (detail === 2) {
        handler(makeDblclick(e));
      }
    } else {
      detail = 1;
    }
    last = now;
  }
  obj.addEventListener("click", simDblclick);
  return {
    dblclick: handler,
    simDblclick
  };
}
function removeDoubleTapListener(obj, handlers) {
  obj.removeEventListener("dblclick", handlers.dblclick);
  obj.removeEventListener("click", handlers.simDblclick);
}

// node_modules/leaflet/src/dom/DomEvent.js
function on(obj, types, fn, context) {
  if (types && typeof types === "object") {
    for (var type in types) {
      addOne(obj, type, types[type], fn);
    }
  } else {
    types = splitWords(types);
    for (var i = 0, len = types.length; i < len; i++) {
      addOne(obj, types[i], fn, context);
    }
  }
  return this;
}
var eventsKey = "_leaflet_events";
function off(obj, types, fn, context) {
  if (arguments.length === 1) {
    batchRemove(obj);
    delete obj[eventsKey];
  } else if (types && typeof types === "object") {
    for (var type in types) {
      removeOne(obj, type, types[type], fn);
    }
  } else {
    types = splitWords(types);
    if (arguments.length === 2) {
      batchRemove(obj, function(type2) {
        return indexOf(types, type2) !== -1;
      });
    } else {
      for (var i = 0, len = types.length; i < len; i++) {
        removeOne(obj, types[i], fn, context);
      }
    }
  }
  return this;
}
function batchRemove(obj, filterFn) {
  for (var id in obj[eventsKey]) {
    var type = id.split(/\d/)[0];
    if (!filterFn || filterFn(type)) {
      removeOne(obj, type, null, null, id);
    }
  }
}
var mouseSubst = {
  mouseenter: "mouseover",
  mouseleave: "mouseout",
  wheel: !("onwheel" in window) && "mousewheel"
};
function addOne(obj, type, fn, context) {
  var id = type + stamp(fn) + (context ? "_" + stamp(context) : "");
  if (obj[eventsKey] && obj[eventsKey][id]) {
    return this;
  }
  var handler = function(e) {
    return fn.call(context || obj, e || window.event);
  };
  var originalHandler = handler;
  if (!Browser_default.touchNative && Browser_default.pointer && type.indexOf("touch") === 0) {
    handler = addPointerListener(obj, type, handler);
  } else if (Browser_default.touch && type === "dblclick") {
    handler = addDoubleTapListener(obj, handler);
  } else if ("addEventListener" in obj) {
    if (type === "touchstart" || type === "touchmove" || type === "wheel" || type === "mousewheel") {
      obj.addEventListener(mouseSubst[type] || type, handler, Browser_default.passiveEvents ? { passive: false } : false);
    } else if (type === "mouseenter" || type === "mouseleave") {
      handler = function(e) {
        e = e || window.event;
        if (isExternalTarget(obj, e)) {
          originalHandler(e);
        }
      };
      obj.addEventListener(mouseSubst[type], handler, false);
    } else {
      obj.addEventListener(type, originalHandler, false);
    }
  } else {
    obj.attachEvent("on" + type, handler);
  }
  obj[eventsKey] = obj[eventsKey] || {};
  obj[eventsKey][id] = handler;
}
function removeOne(obj, type, fn, context, id) {
  id = id || type + stamp(fn) + (context ? "_" + stamp(context) : "");
  var handler = obj[eventsKey] && obj[eventsKey][id];
  if (!handler) {
    return this;
  }
  if (!Browser_default.touchNative && Browser_default.pointer && type.indexOf("touch") === 0) {
    removePointerListener(obj, type, handler);
  } else if (Browser_default.touch && type === "dblclick") {
    removeDoubleTapListener(obj, handler);
  } else if ("removeEventListener" in obj) {
    obj.removeEventListener(mouseSubst[type] || type, handler, false);
  } else {
    obj.detachEvent("on" + type, handler);
  }
  obj[eventsKey][id] = null;
}
function preventDefault(e) {
  if (e.preventDefault) {
    e.preventDefault();
  } else {
    e.returnValue = false;
  }
  return this;
}
function getPropagationPath(ev) {
  if (ev.composedPath) {
    return ev.composedPath();
  }
  var path = [];
  var el = ev.target;
  while (el) {
    path.push(el);
    el = el.parentNode;
  }
  return path;
}
var wheelPxFactor = Browser_default.linux && Browser_default.chrome ? window.devicePixelRatio : Browser_default.mac ? window.devicePixelRatio * 3 : window.devicePixelRatio > 0 ? 2 * window.devicePixelRatio : 1;
function isExternalTarget(el, e) {
  var related = e.relatedTarget;
  if (!related) {
    return true;
  }
  try {
    while (related && related !== el) {
      related = related.parentNode;
    }
  } catch (err) {
    return false;
  }
  return related !== el;
}

// node_modules/leaflet/src/dom/DomUtil.js
var TRANSFORM = testProp(
  ["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]
);
var TRANSITION = testProp(
  ["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]
);
var TRANSITION_END = TRANSITION === "webkitTransition" || TRANSITION === "OTransition" ? TRANSITION + "End" : "transitionend";
function getStyle(el, style2) {
  var value = el.style[style2] || el.currentStyle && el.currentStyle[style2];
  if ((!value || value === "auto") && document.defaultView) {
    var css = document.defaultView.getComputedStyle(el, null);
    value = css ? css[style2] : null;
  }
  return value === "auto" ? null : value;
}
function create2(tagName, className, container) {
  var el = document.createElement(tagName);
  el.className = className || "";
  if (container) {
    container.appendChild(el);
  }
  return el;
}
function testProp(props) {
  var style2 = document.documentElement.style;
  for (var i = 0; i < props.length; i++) {
    if (props[i] in style2) {
      return props[i];
    }
  }
  return false;
}
var disableTextSelection;
var enableTextSelection;
var _userSelect;
if ("onselectstart" in document) {
  disableTextSelection = function() {
    on(window, "selectstart", preventDefault);
  };
  enableTextSelection = function() {
    off(window, "selectstart", preventDefault);
  };
} else {
  userSelectProperty = testProp(
    ["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]
  );
  disableTextSelection = function() {
    if (userSelectProperty) {
      var style2 = document.documentElement.style;
      _userSelect = style2[userSelectProperty];
      style2[userSelectProperty] = "none";
    }
  };
  enableTextSelection = function() {
    if (userSelectProperty) {
      document.documentElement.style[userSelectProperty] = _userSelect;
      _userSelect = void 0;
    }
  };
}
var userSelectProperty;

// node_modules/leaflet/src/layer/marker/Icon.Default.js
var IconDefault = Icon.extend({
  options: {
    iconUrl: "marker-icon.png",
    iconRetinaUrl: "marker-icon-2x.png",
    shadowUrl: "marker-shadow.png",
    iconSize: [25, 41],
    iconAnchor: [12, 41],
    popupAnchor: [1, -34],
    tooltipAnchor: [16, -28],
    shadowSize: [41, 41]
  },
  _getIconUrl: function(name) {
    if (typeof IconDefault.imagePath !== "string") {
      IconDefault.imagePath = this._detectIconPath();
    }
    return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);
  },
  _stripUrl: function(path) {
    var strip = function(str, re, idx) {
      var match = re.exec(str);
      return match && match[idx];
    };
    path = strip(path, /^url\((['"])?(.+)\1\)$/, 2);
    return path && strip(path, /^(.*)marker-icon\.png$/, 1);
  },
  _detectIconPath: function() {
    var el = create2("div", "leaflet-default-icon-path", document.body);
    var path = getStyle(el, "background-image") || getStyle(el, "backgroundImage");
    document.body.removeChild(el);
    path = this._stripUrl(path);
    if (path) {
      return path;
    }
    var link = document.querySelector('link[href$="leaflet.css"]');
    if (!link) {
      return "";
    }
    return link.href.substring(0, link.href.length - "leaflet.css".length - 1);
  }
});
export {
  IconDefault
};
//# sourceMappingURL=leaflet_src_layer_marker_Icon__Default.js.map
